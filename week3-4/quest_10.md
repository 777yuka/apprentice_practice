# プロセス・ジョブを管理できる

## 1. プロセス

全ユーザーのプロセスを表示してください。
<br>

### ▼回答
```bash
$ ps aux
```
出力結果
```bash
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   4624  3336 pts/0    Ss+  02:13   0:00 /bin/bash
root        12  0.0  0.0   4624  3716 pts/1    Ss   02:14   0:00 /bin/bash
root        24  0.0  0.0   7060  1544 pts/1    R+   02:18   0:00 ps aux
```
  
- プロセスとは  
コンピューター上で実行中のプログラムのことです。  
コンピューターは、CPU時間やメモリ、ハードディスクの使用など、各プロセスが必要とするリソースを管理し、それぞれのプロセスが正しく実行されるように制御します。  
プロセスには、親プロセスと子プロセスの関係があり、親プロセスから子プロセスが作られ、その子プロセスがさらに別の子プロセスを作ることができます。  
プロセスは、OSが提供するプロセス管理機能によって制御され、プロセスごとに一意のプロセスIDが割り当てられます。
  
- 全ユーザーのプロセスとは  
全ユーザーのプロセスとは、現在システム上で実行されている全てのプロセスを指します。  
通常、ユーザーが自分で起動したプロセスは自分のユーザーIDで実行されますが、管理者がシステム上で実行されている全てのプロセスを確認したい場合には、全ユーザーのプロセスを表示するコマンドを使用します。
  
- 親プロセスと子プロセスの仕組み  
プロセスの親子関係とは、プロセスが生成されるときに生成元となるプロセスとの間に階層構造ができることを意味します。親プロセスは、新しいプロセスを生成したり、生成したプロセスに対して何らかの操作を実行したりすることができます。一方、子プロセスは、親プロセスから生成され、親プロセスの状態を引き継いで自身のプロセスを実行します。  
例えば、あなたがゲームをプレイしているとき、ゲームが1つのプロセスとして実行されています。その中で、ゲームの画面を表示するプロセスがあり、別のプロセスが音楽を再生し、また別のプロセスがネットワーク通信を行っているかもしれません。これらのプロセスは、親子関係にあることがあります。  
この親子関係の仕組みが必要な理由は、プロセスを管理するためです。親プロセスは、生成した子プロセスを監視することができます。子プロセスが異常終了した場合や、不正な操作を行おうとした場合、親プロセスがそれを検知し、適切な対処を行うことができます。また、子プロセスが別のプロセスを生成することで、複雑な処理を実現することができます。  
  
- 出力結果の項目について
  - USER: プロセスを実行しているユーザー名。
  - PID: プロセスID。一意の番号で、プロセスを一意に識別するために使用されます。
  - %CPU: CPU使用率。直近のCPU時間のうち、このプロセスが使用した割合。
  - %MEM: メモリ使用率。このプロセスが使用している物理メモリの割合。
  - VSZ: 仮想メモリサイズ。プロセスが使用している仮想メモリの総量。単位はキロバイト。
  - RSS: リアルメモリサイズ。プロセスが使用している物理メモリの総量。単位はキロバイト。
  - TTY: プロセスが実行されている端末名。バックグラウンドで実行されているプロセスは "?" が表示される。
  - STAT: プロセスの状態を示すステータス。一般的なステータスは S (スリープ状態)、R (実行中)、Z (ゾンビ状態) などがあります。
  - START: プロセスが開始された日付と時刻。
  - TIME: プロセスがCPUを使用した時間の合計。単位は分:秒。
  - COMMAND: プロセスを起動したコマンド。

---

## 2. バックグラウンド

sleep コマンドを利用して処理を100秒停止する処理を、バックグラウンドで実行してください。
<br>

### ▼回答
```bash
$ sleep 100 &
```
出力結果
```bash
[1] 34
```
  
- `&`とは  
最後に & を追加することで、コマンドをバックグラウンドで実行することができます。  
- 出力結果について  
 `[1]`は、バックグラウンドで実行されたジョブの番号を表します。ターミナルで複数のジョブが実行されている場合、それぞれに対して一意の番号が割り当てられます。  
`[1]`の後に表示された`25`は、sleepコマンドのジョブ番号です。プロセスIDではありません。実際のプロセスIDは別の番号で表示されます。

---

## 3. プロセス・ジョブの終了

2でバックグラウンドで実行されている sleep コマンドを終了させてください。
<br>

### ▼回答
まず以下のコマンドで、実行中の`sleep`コマンドのプロセスIDを確認します。
```bash
$ ps aux | grep sleep
```
出力結果
```bash
root        26  0.0  0.0   2788  1056 pts/1    S    02:25   0:00 sleep 100
root        28  0.0  0.0   3468  1472 pts/1    S+   02:25   0:00 grep --color=auto sleep
```
この場合、`26`が`sleep`コマンドのプロセスIDです。  
  
ちなみに、プロセスID`28`は`grep`コマンドのプロセスで、`--color=auto sleep` は `grep` コマンドに対する引数です。具体的には、前のコマンド `ps aux | grep sleep` で `grep`コマンドを使って "sleep" という文字列を含む行を抽出しています。  
ここで、`--color=auto` オプションは、出力に色を付けるために使用されています。
```bash
$ kill 26
```
何も出力がなければ、正常に終了しています。  
（ただし、存在しないプロセスIDを入力したときも何も出力されない可能性あり）  
ちなみに出力があった場合は、エラーです。
```bash
bash: kill: (26) - No such process
[2]+  Done                    sleep 100
```
この出力結果の内容は以下になります。  
  - `bash: kill: (26) - No such process`:  
  `kill` コマンドが失敗しました。`26` というプロセス ID に対応するプロセスが存在しないため、プロセスを終了できませんでした。このメッセージはエラーメッセージであり、プロセスが見つからなかったことを示しています。
  - `[2]+  Done                    sleep 100`:  
   `sleep 100` というコマンドがバックグラウンドで実行され、そのプロセス ID は `26` であったことがわかります。`[2]+` は、2 番目のバックグラウンドプロセスであることを示しています。`Done` は、このバックグラウンドプロセスが正常に終了したことを示しています。
  
- `ps aux | grep sleep`について  
`ps aux`は、現在実行されているすべてのプロセスを表示するLinuxのコマンドです。  
一方、`grep`は、与えられたテキストから特定のパターンに一致する行をフィルタリング（あるデータや情報の中から特定の条件に合致するものだけを選び出すこと）するために使用されます。  
そして、`|`はパイプと呼ばれ、1つのコマンドの出力を別のコマンドの入力として渡すために使用されます。  
つまり、 `ps aux`コマンドの出力を `grep`コマンドに渡して、"sleep"という文字列を含むプロセスをフィルタリングしています。結果として、"sleep"コマンドによって開始されたプロセスの行のみが表示されます。
